//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(non_snake_case)]
use super::{
    ast::{support, AstChildren, AstNode},
    nodes_types::{SyntaxNode, SyntaxToken},
    syntax_kind_gen::SyntaxKind::{self, *},
};
use crate::T;

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExpression {
    pub(crate) syntax: SyntaxNode,
}
impl BinaryExpression {
    pub fn left(&self) -> Option<Term> { support::child(&self.syntax) }
    pub fn operator(&self) -> Option<Operator> { support::child(&self.syntax) }
    pub fn right(&self) -> Option<Term> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Container {
    pub(crate) syntax: SyntaxNode,
}
impl Container {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CustomPropertyDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl CustomPropertyDeclaration {
    pub fn custom_property_set(&self) -> Option<CustomPropertySet> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CustomPropertySet {
    pub(crate) syntax: SyntaxNode,
}
impl CustomPropertySet {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Declaration {
    pub(crate) syntax: SyntaxNode,
}
impl Declaration {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeclarationCommon {
    pub(crate) syntax: SyntaxNode,
}
impl DeclarationCommon {
    pub fn custom_property_declaration(&self) -> Option<CustomPropertyDeclaration> {
        support::child(&self.syntax)
    }
    pub fn declaration(&self) -> Option<Declaration> { support::child(&self.syntax) }
    pub fn expression(&self) -> Option<Expression> { support::child(&self.syntax) }
    pub fn property(&self) -> Option<Property> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Declarations {
    pub(crate) syntax: SyntaxNode,
}
impl Declarations {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Document {
    pub(crate) syntax: SyntaxNode,
}
impl Document {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Expression {
    pub(crate) syntax: SyntaxNode,
}
impl Expression {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FontFace {
    pub(crate) syntax: SyntaxNode,
}
impl FontFace {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Function {
    pub(crate) syntax: SyntaxNode,
}
impl Function {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionArgument {
    pub(crate) syntax: SyntaxNode,
}
impl FunctionArgument {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GridLine {
    pub(crate) syntax: SyntaxNode,
}
impl GridLine {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HexColorValue {
    pub(crate) syntax: SyntaxNode,
}
impl HexColorValue {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Import {
    pub(crate) syntax: SyntaxNode,
}
impl Import {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Keyframe {
    pub(crate) syntax: SyntaxNode,
}
impl Keyframe {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct KeyframeSelector {
    pub(crate) syntax: SyntaxNode,
}
impl KeyframeSelector {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Layer {
    pub(crate) syntax: SyntaxNode,
}
impl Layer {
    pub fn names(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LayerNameList {
    pub(crate) syntax: SyntaxNode,
}
impl LayerNameList {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Media {
    pub(crate) syntax: SyntaxNode,
}
impl Media {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MediaCondition {
    pub(crate) syntax: SyntaxNode,
}
impl MediaCondition {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MediaFeature {
    pub(crate) syntax: SyntaxNode,
}
impl MediaFeature {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MediaQuery {
    pub(crate) syntax: SyntaxNode,
}
impl MediaQuery {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Namespace {
    pub(crate) syntax: SyntaxNode,
}
impl Namespace {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamespacePrefix {
    pub(crate) syntax: SyntaxNode,
}
impl NamespacePrefix {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NumericValue {
    pub(crate) syntax: SyntaxNode,
}
impl NumericValue {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Operator {
    pub(crate) syntax: SyntaxNode,
}
impl Operator {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Page {
    pub(crate) syntax: SyntaxNode,
}
impl Page {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PageBoxMarginBox {
    pub(crate) syntax: SyntaxNode,
}
impl PageBoxMarginBox {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Prio {
    pub(crate) syntax: SyntaxNode,
}
impl Prio {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Property {
    pub(crate) syntax: SyntaxNode,
}
impl Property {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PropertyAtRule {
    pub(crate) syntax: SyntaxNode,
}
impl PropertyAtRule {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RatioValue {
    pub(crate) syntax: SyntaxNode,
}
impl RatioValue {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RuleSet {
    pub(crate) syntax: SyntaxNode,
}
impl RuleSet {
    pub fn selectors(&self) -> AstChildren<Selector> { support::children(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Selector {
    pub(crate) syntax: SyntaxNode,
}
impl Selector {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorAttribute {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorAttribute {
    pub fn namespace_prefix(&self) -> Option<NamespacePrefix> { support::child(&self.syntax) }
    pub fn operator(&self) -> Option<Operator> { support::child(&self.syntax) }
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorClass {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorClass {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorCombinator {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorCombinator {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorCombinatorAllSiblings {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorCombinatorAllSiblings {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorCombinatorParent {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorCombinatorParent {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorCombinatorShadowPiercingDescendant {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorCombinatorShadowPiercingDescendant {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorCombinatorSibling {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorCombinatorSibling {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorElementName {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorElementName {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorIdentifier {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorIdentifier {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorInterpolation {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorInterpolation {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectorPseudo {
    pub(crate) syntax: SyntaxNode,
}
impl SelectorPseudo {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SimpleSelector {
    pub(crate) syntax: SyntaxNode,
}
impl SimpleSelector {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StringLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl StringLiteral {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Supports {
    pub(crate) syntax: SyntaxNode,
}
impl Supports {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SupportsCondition {
    pub(crate) syntax: SyntaxNode,
}
impl SupportsCondition {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Term {
    pub(crate) syntax: SyntaxNode,
}
impl Term {
    pub fn expression(&self) -> Option<Expression> { support::child(&self.syntax) }
    pub fn operator(&self) -> Option<Operator> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Todo {
    pub(crate) syntax: SyntaxNode,
}
impl Todo {
    pub fn identifier_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![identifier])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnicodeRange {
    pub(crate) syntax: SyntaxNode,
}
impl UnicodeRange {
    pub fn range_end(&self) -> Option<Todo> { support::child(&self.syntax) }
    pub fn range_start(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnknownAtRule {
    pub(crate) syntax: SyntaxNode,
}
impl UnknownAtRule {
    pub fn name(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UriLiteral {
    pub(crate) syntax: SyntaxNode,
}
impl UriLiteral {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ViewPort {
    pub(crate) syntax: SyntaxNode,
}
impl ViewPort {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct XcssVariableDeclaration {
    pub(crate) syntax: SyntaxNode,
}
impl XcssVariableDeclaration {
    pub fn todo(&self) -> Option<Todo> { support::child(&self.syntax) }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AbstractDeclaration {
    Declaration(Declaration),
    XcssVariableDeclaration(XcssVariableDeclaration),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BodyDeclaration {
    Container(Container),
    CustomPropertySet(CustomPropertySet),
    Document(Document),
    FontFace(FontFace),
    Keyframe(Keyframe),
    KeyframeSelector(KeyframeSelector),
    Layer(Layer),
    Media(Media),
    Page(Page),
    PageBoxMarginBox(PageBoxMarginBox),
    PropertyAtRule(PropertyAtRule),
    RuleSet(RuleSet),
    Supports(Supports),
    UnknownAtRule(UnknownAtRule),
    ViewPort(ViewPort),
}
impl AstNode for BinaryExpression {
    fn can_cast(kind: SyntaxKind) -> bool { kind == BINARY_EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Container {
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONTAINER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CustomPropertyDeclaration {
    fn can_cast(kind: SyntaxKind) -> bool { kind == CUSTOM_PROPERTY_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CustomPropertySet {
    fn can_cast(kind: SyntaxKind) -> bool { kind == CUSTOM_PROPERTY_SET }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Declaration {
    fn can_cast(kind: SyntaxKind) -> bool { kind == DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for DeclarationCommon {
    fn can_cast(kind: SyntaxKind) -> bool { kind == DECLARATION_COMMON }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Declarations {
    fn can_cast(kind: SyntaxKind) -> bool { kind == DECLARATIONS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Document {
    fn can_cast(kind: SyntaxKind) -> bool { kind == DOCUMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Expression {
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPRESSION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for FontFace {
    fn can_cast(kind: SyntaxKind) -> bool { kind == FONT_FACE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Function {
    fn can_cast(kind: SyntaxKind) -> bool { kind == FUNCTION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for FunctionArgument {
    fn can_cast(kind: SyntaxKind) -> bool { kind == FUNCTION_ARGUMENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for GridLine {
    fn can_cast(kind: SyntaxKind) -> bool { kind == GRID_LINE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for HexColorValue {
    fn can_cast(kind: SyntaxKind) -> bool { kind == HEX_COLOR_VALUE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Import {
    fn can_cast(kind: SyntaxKind) -> bool { kind == IMPORT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Keyframe {
    fn can_cast(kind: SyntaxKind) -> bool { kind == KEYFRAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for KeyframeSelector {
    fn can_cast(kind: SyntaxKind) -> bool { kind == KEYFRAME_SELECTOR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Layer {
    fn can_cast(kind: SyntaxKind) -> bool { kind == LAYER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for LayerNameList {
    fn can_cast(kind: SyntaxKind) -> bool { kind == LAYER_NAME_LIST }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Media {
    fn can_cast(kind: SyntaxKind) -> bool { kind == MEDIA }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MediaCondition {
    fn can_cast(kind: SyntaxKind) -> bool { kind == MEDIA_CONDITION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MediaFeature {
    fn can_cast(kind: SyntaxKind) -> bool { kind == MEDIA_FEATURE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for MediaQuery {
    fn can_cast(kind: SyntaxKind) -> bool { kind == MEDIA_QUERY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Namespace {
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMESPACE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NamespacePrefix {
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAMESPACE_PREFIX }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NumericValue {
    fn can_cast(kind: SyntaxKind) -> bool { kind == NUMERIC_VALUE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Operator {
    fn can_cast(kind: SyntaxKind) -> bool { kind == OPERATOR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Page {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAGE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PageBoxMarginBox {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAGE_BOX_MARGIN_BOX }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Prio {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PRIO }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Property {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PROPERTY }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PropertyAtRule {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PROPERTY_AT_RULE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RatioValue {
    fn can_cast(kind: SyntaxKind) -> bool { kind == RATIO_VALUE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for RuleSet {
    fn can_cast(kind: SyntaxKind) -> bool { kind == RULE_SET }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Selector {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorAttribute {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_ATTRIBUTE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorClass {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_CLASS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorCombinator {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_COMBINATOR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorCombinatorAllSiblings {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_COMBINATOR_ALL_SIBLINGS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorCombinatorParent {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_COMBINATOR_PARENT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorCombinatorShadowPiercingDescendant {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_COMBINATOR_SHADOW_PIERCING_DESCENDANT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorCombinatorSibling {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_COMBINATOR_SIBLING }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorElementName {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_ELEMENT_NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorIdentifier {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_IDENTIFIER }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorInterpolation {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_INTERPOLATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectorPseudo {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECTOR_PSEUDO }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SimpleSelector {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SIMPLE_SELECTOR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for StringLiteral {
    fn can_cast(kind: SyntaxKind) -> bool { kind == STRING_LITERAL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Supports {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SUPPORTS }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SupportsCondition {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SUPPORTS_CONDITION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Term {
    fn can_cast(kind: SyntaxKind) -> bool { kind == TERM }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Todo {
    fn can_cast(kind: SyntaxKind) -> bool { kind == TODO }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UnicodeRange {
    fn can_cast(kind: SyntaxKind) -> bool { kind == UNICODE_RANGE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UnknownAtRule {
    fn can_cast(kind: SyntaxKind) -> bool { kind == UNKNOWN_AT_RULE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for UriLiteral {
    fn can_cast(kind: SyntaxKind) -> bool { kind == URI_LITERAL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ViewPort {
    fn can_cast(kind: SyntaxKind) -> bool { kind == VIEW_PORT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for XcssVariableDeclaration {
    fn can_cast(kind: SyntaxKind) -> bool { kind == XCSS_VARIABLE_DECLARATION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<Declaration> for AbstractDeclaration {
    fn from(node: Declaration) -> AbstractDeclaration { AbstractDeclaration::Declaration(node) }
}
impl From<XcssVariableDeclaration> for AbstractDeclaration {
    fn from(node: XcssVariableDeclaration) -> AbstractDeclaration {
        AbstractDeclaration::XcssVariableDeclaration(node)
    }
}
impl AstNode for AbstractDeclaration {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, DECLARATION | XCSS_VARIABLE_DECLARATION)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DECLARATION => AbstractDeclaration::Declaration(Declaration { syntax }),
            XCSS_VARIABLE_DECLARATION => {
                AbstractDeclaration::XcssVariableDeclaration(XcssVariableDeclaration { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AbstractDeclaration::Declaration(it) => &it.syntax,
            AbstractDeclaration::XcssVariableDeclaration(it) => &it.syntax,
        }
    }
}
impl From<Container> for BodyDeclaration {
    fn from(node: Container) -> BodyDeclaration { BodyDeclaration::Container(node) }
}
impl From<CustomPropertySet> for BodyDeclaration {
    fn from(node: CustomPropertySet) -> BodyDeclaration { BodyDeclaration::CustomPropertySet(node) }
}
impl From<Document> for BodyDeclaration {
    fn from(node: Document) -> BodyDeclaration { BodyDeclaration::Document(node) }
}
impl From<FontFace> for BodyDeclaration {
    fn from(node: FontFace) -> BodyDeclaration { BodyDeclaration::FontFace(node) }
}
impl From<Keyframe> for BodyDeclaration {
    fn from(node: Keyframe) -> BodyDeclaration { BodyDeclaration::Keyframe(node) }
}
impl From<KeyframeSelector> for BodyDeclaration {
    fn from(node: KeyframeSelector) -> BodyDeclaration { BodyDeclaration::KeyframeSelector(node) }
}
impl From<Layer> for BodyDeclaration {
    fn from(node: Layer) -> BodyDeclaration { BodyDeclaration::Layer(node) }
}
impl From<Media> for BodyDeclaration {
    fn from(node: Media) -> BodyDeclaration { BodyDeclaration::Media(node) }
}
impl From<Page> for BodyDeclaration {
    fn from(node: Page) -> BodyDeclaration { BodyDeclaration::Page(node) }
}
impl From<PageBoxMarginBox> for BodyDeclaration {
    fn from(node: PageBoxMarginBox) -> BodyDeclaration { BodyDeclaration::PageBoxMarginBox(node) }
}
impl From<PropertyAtRule> for BodyDeclaration {
    fn from(node: PropertyAtRule) -> BodyDeclaration { BodyDeclaration::PropertyAtRule(node) }
}
impl From<RuleSet> for BodyDeclaration {
    fn from(node: RuleSet) -> BodyDeclaration { BodyDeclaration::RuleSet(node) }
}
impl From<Supports> for BodyDeclaration {
    fn from(node: Supports) -> BodyDeclaration { BodyDeclaration::Supports(node) }
}
impl From<UnknownAtRule> for BodyDeclaration {
    fn from(node: UnknownAtRule) -> BodyDeclaration { BodyDeclaration::UnknownAtRule(node) }
}
impl From<ViewPort> for BodyDeclaration {
    fn from(node: ViewPort) -> BodyDeclaration { BodyDeclaration::ViewPort(node) }
}
impl AstNode for BodyDeclaration {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            CONTAINER
                | CUSTOM_PROPERTY_SET
                | DOCUMENT
                | FONT_FACE
                | KEYFRAME
                | KEYFRAME_SELECTOR
                | LAYER
                | MEDIA
                | PAGE
                | PAGE_BOX_MARGIN_BOX
                | PROPERTY_AT_RULE
                | RULE_SET
                | SUPPORTS
                | UNKNOWN_AT_RULE
                | VIEW_PORT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CONTAINER => BodyDeclaration::Container(Container { syntax }),
            CUSTOM_PROPERTY_SET => BodyDeclaration::CustomPropertySet(CustomPropertySet { syntax }),
            DOCUMENT => BodyDeclaration::Document(Document { syntax }),
            FONT_FACE => BodyDeclaration::FontFace(FontFace { syntax }),
            KEYFRAME => BodyDeclaration::Keyframe(Keyframe { syntax }),
            KEYFRAME_SELECTOR => BodyDeclaration::KeyframeSelector(KeyframeSelector { syntax }),
            LAYER => BodyDeclaration::Layer(Layer { syntax }),
            MEDIA => BodyDeclaration::Media(Media { syntax }),
            PAGE => BodyDeclaration::Page(Page { syntax }),
            PAGE_BOX_MARGIN_BOX => BodyDeclaration::PageBoxMarginBox(PageBoxMarginBox { syntax }),
            PROPERTY_AT_RULE => BodyDeclaration::PropertyAtRule(PropertyAtRule { syntax }),
            RULE_SET => BodyDeclaration::RuleSet(RuleSet { syntax }),
            SUPPORTS => BodyDeclaration::Supports(Supports { syntax }),
            UNKNOWN_AT_RULE => BodyDeclaration::UnknownAtRule(UnknownAtRule { syntax }),
            VIEW_PORT => BodyDeclaration::ViewPort(ViewPort { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            BodyDeclaration::Container(it) => &it.syntax,
            BodyDeclaration::CustomPropertySet(it) => &it.syntax,
            BodyDeclaration::Document(it) => &it.syntax,
            BodyDeclaration::FontFace(it) => &it.syntax,
            BodyDeclaration::Keyframe(it) => &it.syntax,
            BodyDeclaration::KeyframeSelector(it) => &it.syntax,
            BodyDeclaration::Layer(it) => &it.syntax,
            BodyDeclaration::Media(it) => &it.syntax,
            BodyDeclaration::Page(it) => &it.syntax,
            BodyDeclaration::PageBoxMarginBox(it) => &it.syntax,
            BodyDeclaration::PropertyAtRule(it) => &it.syntax,
            BodyDeclaration::RuleSet(it) => &it.syntax,
            BodyDeclaration::Supports(it) => &it.syntax,
            BodyDeclaration::UnknownAtRule(it) => &it.syntax,
            BodyDeclaration::ViewPort(it) => &it.syntax,
        }
    }
}
impl std::fmt::Display for AbstractDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BodyDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinaryExpression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Container {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CustomPropertyDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CustomPropertySet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Declaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclarationCommon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Declarations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Document {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expression {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FontFace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Function {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionArgument {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GridLine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for HexColorValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Import {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Keyframe {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for KeyframeSelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Layer {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LayerNameList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Media {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MediaCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MediaFeature {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MediaQuery {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Namespace {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamespacePrefix {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NumericValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Operator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Page {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PageBoxMarginBox {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Prio {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Property {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PropertyAtRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RatioValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RuleSet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Selector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorAttribute {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorClass {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorCombinator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorCombinatorAllSiblings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorCombinatorParent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorCombinatorShadowPiercingDescendant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorCombinatorSibling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorElementName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorIdentifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorInterpolation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectorPseudo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SimpleSelector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StringLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Supports {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SupportsCondition {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Term {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Todo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnicodeRange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnknownAtRule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UriLiteral {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ViewPort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for XcssVariableDeclaration {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
